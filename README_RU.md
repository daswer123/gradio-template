```markdown
# README

## О проекте

Данный проект представляет собой пример структуры приложения, использующего [Gradio](https://www.gradio.app/) для создания интерактивного веб-интерфейса, с акцентом на модульный подход, управляемые состояния, настройку через базу данных и удобный менеджмент взаимосвязей между модулями. Код организован так, чтобы можно было легко добавлять новые модули, настройки и взаимодействия между компонентами.

Проект демонстрирует следующие ключевые аспекты:

1. **Модульная архитектура**: Все функциональные части приложения разделены на отдельные модули. Это упрощает поддержку кода, его расширение и повторное использование компонентов.
2. **State Manager (Управление состоянием)**: Используется централизованное хранение состояния и настроек приложения. Общий стейт позволяет разным модулям взаимодействовать через единый источник правды.
3. **Dynamic UI (Динамический интерфейс)**: Интерфейс создаётся и конфигурируется через Gradio, с поддержкой вкладок, компонентов ввода/вывода и логики обработки событий.
4. **Module Connection Manager (Менеджер подключений между модулями)**: Специальный компонент для управления соединениями (зависимостями) между модулями. Это позволяет легко описывать, как вывод одного модуля может быть входом для другого.
5. **Использование базы данных**: Настройки приложения (логгирование, тема, хост, порт и пр.) сохраняются в SQLite-базу данных `user.db`. При первом запуске создаются дефолтные настройки, которые можно изменять в процессе работы.
6. **Компонентный подход к UI**: Каждый модуль определяет свои визуальные компоненты, логику их обновления и обработку событий. Это позволяет изолировать функциональность и упрощает разработку сложных интерфейсов.
7. **Пример кода модулей**: В проекте есть простые модули для обработки текста, отображения результата, загрузки текста, а также пример с “упрощенным” вариантом (окончание `_simple` в названии файла модуля показывает, что весь код модуля собран в одном файле) и более “сложным” вариант с разделением на папки и файлы.

## Основные директории и файлы

```bash
./
├── app.py                    # Главный файл запуска приложения
├── helper.py                 # Скрипт для вывода структуры проекта и его содержимого
├── project_structure.txt     # Автоматически сгенерированный файл со структурой проекта
├── README.md                 # Этот README
├── requirements.txt          # Зависимости проекта
├── user.db                   # SQLite база данных для хранения настроек

├── app_configuration/        # Настройки и конфигурация приложения
│   ├── app_config.py         # Обертка для базовой конфигурации и инициализации модулей
│   ├── models.py             # Модели и перечисления (LogLevel и т.д.)
│   ├── settings.py           # Определение дефолтных настроек приложения
│   ├── state.py              # Менеджер состояния и настроек, работа с БД
│   ├── __init__.py

├── modules/                  # Папка с модулями приложения
│   ├── base.py               # Базовый класс для всех модулей
│   ├── connection_manager.py # Менеджер подключения модулей
│   ├── test_loader.py        # Пример модуля загрузки и обработки текста (посимвольно)
│   ├── text_processor_simple.py 
│       # Пример простого модуля обработки текста в одном файле: ввод -> вывод в upper-case
│   ├── text_display/         # Более сложный пример модуля отображения текста
│   │   ├── base.py           # Основной класс TextDisplay модуля
│   │   ├── functions.py      # Логика извлечения и форматирования текста из других модулей
│   │   ├── handlers.py       # Обработчики событий (кнопки refresh и т.д.)
│   │   ├── ui.py             # UI-компоненты для модуля отображения
│   │   ├── __init__.py
│   ├── __init__.py           # Регистрация и экспорт модулей

├── scripts/
│   ├── YOUR_SCRIPT_HERE      # Пример для пользовательских скриптов

├── utils/
│   ├── database.py           # Взаимодействие с SQLite БД (хранение настроек)
│   ├── logger.py             # Утилита логирования с уровнями логов
│   ├── __pycache__/

```

## Компоненты и их роли

- **app.py**: 
  - Точка входа в приложение.  
  - Создаёт экземпляр класса `Application`, инициализирует все модули и запускает Gradio интерфейс.
  - Здесь задаются соединения между модулями `MODULE_CONNECTIONS`.

- **app_configuration**: 
  - `app_config.py` – Обертка для инициализации приложения, настройки core-компонентов и модулей.  
  - `settings.py` – Определение стандартных настроек приложения (тема, логирование, порт и т.д.).  
  - `state.py` – Хранит текущее состояние приложения, настройки, данные модулей, а также компонентные состояния. Реализует логику загрузки/синхронизации настроек из базы.  
  - `models.py` – Описывает вспомогательные модели и перечисления, например уровни логирования (`LogLevel`).

- **modules**: 
  - `base.py` – Базовый класс для всех модулей, определяющий основной интерфейс.
  - `connection_manager.py` – Определяет класс `ModuleConnectionManager`, отвечающий за регистрацию и соединение модулей (кто от кого получает данные).
  - `test_loader.py` – Пример модуля, который загружает текст и обрабатывает его посимвольно, показывая прогресс. Демонстрирует асинхронную обработку, остановку процесса и обновление UI.
  - `text_processor_simple.py` – Упрощенный модуль: весь код в одном файле. Пример: вводим текст – получаем его верхний регистр. Показывает, как можно быстро создать компонент без сложной структуры.
  - `text_display/` – Более сложный пример, где функциональность разбита на несколько файлов:
    - `ui.py` – Определяет UI компоненты (textbox, button, markdown).
    - `handlers.py` – Определяет обработчики событий (нажатие кнопки refresh и т.д.).
    - `functions.py` – Бизнес-логика получения и форматирования данных из state.
    - `base.py` – Объединяет всё воедино в класс `TextDisplay`.
  
- **utils**: 
  - `database.py` – Класс `Database` для взаимодействия с SQLite (чтение/запись настроек).
  - `logger.py` – Унифицированный логгер с уровнем логирования, привязкой к источнику и возможностью включать debug-режим.

## Взаимодействие между модулями

Приложение использует `ModuleConnectionManager` для соединения модулей. К примеру, `proc1` (TextProcessor) может быть источником данных для `display1` (TextDisplay).  
В `app.py` в списке `MODULE_CONNECTIONS` вы можете указать связки:

```python
MODULE_CONNECTIONS = [
   ("proc1", "display1", "display_text"),
]
```

Это означает, что текст, обработанный модулем `proc1`, может отображаться в `display1` при обновлении интерфейса. Таким образом логика работы модулей становится связной, но каждый модуль остаётся изолированным функциональным блоком.

## Запуск приложения

1. Установите зависимости:
   ```bash
   pip install -r requirements.txt
   ```

2. Запустите приложение:
   ```bash
   python app.py
   ```

   После запуска в консоли появится информация о доступном интерфейсе, обычно по адресу: [http://localhost:7860](http://localhost:7860).

3. Откройте браузер и перейдите по этому адресу. Вы увидите интерфейс с вкладками, компонентами ввода текста, кнопками для обработки и отображения результата.

## Настройки приложения

Настройки (тема, логирование, порт, хост, share и т.д.) хранятся в базе `user.db`. При первом запуске они инициализируются значениями по умолчанию. Вы можете вручную изменить их, а также в коде `state.py` инициализировать или обновить настройки.

## Заключение

Данный шаблон может послужить основой для создания более сложных приложений:

- Вы можете добавлять новые модули, каждый со своей логикой, UI и обработчиками.
- Изменять способ хранения состояния (добавлять новую бизнес-логику в `state.py`).
- Настраивать взаимодействие между модулями через `ModuleConnectionManager`.
- Использовать Gradio как фронтенд, оборачивая сложную логику в удобные для пользователя интерфейсы.

Благодаря модульному подходу, код становится более структурированным, гибким и расширяемым.
```